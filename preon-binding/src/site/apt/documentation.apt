
Documentation

* Introduction

  A Codec basically captures the binary representation of in-memory
representation of a chunk of data. Since that is what they capture, it
should be fairly straightforward to turn that into documentation of
the binary representation. But since the whole conversion between the
binary representation and the in-memory representation can be quite
involved, you would rather not leave that some external component. In
fact, in order to make Preon truly extensible, the responsibility for
generating documentation is within the Codec itself.

  So, that means that a Codec needs to implement a contract to support
document generation. And since a Codec is most often the first
component in a chain of Codecs, it will have to use the interface of
the other Codecs to generate documentation about the details it does
not control itself. A Codec of a list is dependent on a Codec of its
elements. The Codec of a list should be able to generate documentation
on the number of elements in the list, and the type of elements in the
list. The Codec for the elemement should be able to specify the
details for that type of element.

  However, if all Preon would do is call its Codecs to generate their
description in a single line, that would generate pretty awful
documentation. If you want documentation, then you of course want
readable documentation. Documentation that uses proper structuring
mechanisms to ease reading. If something takes more than a couple of
lines to explain, it probably justifies having it documented in a
dedicated section, and then link to that wherever you need it.

  Apart from generating a human readable description, you also want to
capture some structural aspects. For instance, it is not uncommon for
struct-type of data to have a table with its elements, and a column
stating the number of bits that will be occupied by the individual
elements. (I didn't make that up. Check Wikipedia for some binary
formats, and you will find out for yourself.)

* Interface

  Given all of the above, it is clear that the interface generating
the documentation (the interface to be implemented by Codecs) should
at least have a couple of capabilities:

 * The Codec should be able to decide wether it considers itself
   important enough for a dedicated section. If you have a numeric
   attribute on an object, then the corresponding Codec is most likely
   the NumericCodec. All you can really say about the way that number
   is encoded is something about the number of bits, and the byte
   order. That's probably it. In that case, you don't want the Codec
   to claim a dedicated section.

 * The Codec should be able to render a human readable description of
   the number of bits it expects to occupy. There are a couple of
   options. Either you the number of bits is a fixed size, unknown, or
   can be derived from data read further upstream. The API should be
   able to cater for all three of these situations; in fact, in the
   third case, it should be possible to turn that expression in
   something human readable, with links to the pieces of data it
   depends upon. (For sure not a simple requirement, but on the plus
   side: it is already implemented.)

 * The Codec should be able to render a reference to itself, to be
   used in the documentation generated by Codecs depending on it.

 * The Codec should be able to render a full description to some
   context. 

 * The Codec should be able to render a descriptive (and ideally
   unique) label of itself. Why? Well, if you want to offer the Codec
   the option to render itself in a dedicated section, you want to
   have a name for that section.

* Context

  As you might have noticed, the previous section didn't explicitly
mention the target document type. Sure, we saw that the Codec needs to
be able to generate a reference to itself, but we didn't actually see
what that reference needs to be. In fact, the previous section did not
mention anything like a output document type at all. 

  Now, what I am about to say now might smell like retrofitting a
solution to a requirement, but I still think it is a valid
requirement, until somebody prooves me wrong. 

  The thing is, Preon is extensible. If the Codec would pick HTML as
the output document type today, then it would be quite a safe bet, but
it would make it hard to ever use something else than HTML. If Preon
would pick a fairly widely accepted general documentation format such
as DocBook, then it would automatically reduce the number of people
capable of writing a Codec to a handfull of people who would be
willing to learn DocBook. APT may be fairly widely accepted, but then
again, which APT? MediaWiki? Doxia?

  Apart from all of that, it would make the interface a little
fragile. If your Codecs would have to write to an OutputStream, how
would you know what the content type expected would be? How would you
know about the document context. How would you know that you are
expected to write contents for an HTML paragraph, instead of a DocBook
section? 

* The Answer

  Given the requirements above, it should be fairly easy to understand
the design choices made for Preon. Preon opted for having the Codecs
being capable of returning a CodecDescriptor that implements most of
the features listed in the Interface section. True, in the current
incarnation of Preon, the names of the operations are a little
awkward, but the intention is still the same.

  There is one thing missing in the CodecDescriptor interface. It does
not return the number of bits inhabited by the binary encoded
representation of a piece of data. But the good news is: that is
already provided by the Codec itself. The Codec itself has a getSize()
operation. It returns either null - in case the size is really unknown
- or a Limbo expression. And Limbo expressions are capable of
rendering themselves to a document. And what is more, a Limbo
expression will also render the references in a way that is in sync
with Preon's conceptual notion of the data structure to be encoded. So
it's the Expression itself that is capable of rendering itself to a
document in a human-readable way.

  Then, last but not least, the context. In Preon, the
CodecDescriptors receive a different context, depending on the scope
of operation. An operation that is only intended to write a reference,
gets a paragraph context. It will never be able to write outside of
that paragraph. It will be able to use links, italics, and other
inline type of document elements, but that's it. However, an operation
that is expected to generate content in a dedicated section gets
access to the full range of document elements you could have in that
section. That operation is able to add tables, figures, multiple
paragraphs, etc. But again, it will be impossible to write outside of
the context of that section.

  Now, there is one thing missing from all of this. In Preon, many
Codecs will be decorated by others. For instance, you are able to
specify that a Codec is only allowed to read from a slice of data. So,
you cannot read beyond that slice. The Codec itself doesn't know of
this condition. That Codec might be configured to just continue to
read until it hits an 'end of file'. But if that Codec is decorated by
another Codec offering it just a slice of underlying data, the
documentation should be able to state something about that
slice. 

  Let's take encryption, as an alternative example. In Preon, it is
perfectly feasible to have a Codec for a certain piece of data (say an
address) decorated by a Codec that deals with encrypted data. The
encrypting Codec would decrypt data coming in, and pass it on to the
address Codec. The documentation of the address Codec is still
valid. However, the decorating encryption Codec should leave some
traces in the generated documentation as well. You could imagine the
documentation would be something like this:

---------

An address. (Find details here.) The binary representation of the
address is stored encrypted using a Blowfish cipher, based on a shared
secret. The format reserves 256 bytes for the encrypted address.

---------

  In the example above, the documentation starts with the format is
documented starting with the inner-most Codec, and it's then adding
more content while working its way out. (Note to self: I guess this
means we need to be able to render something without 'a' or 'the.)
(Second note to self: it also means that we need to be able to be able
to generate a different type of reference?)

______

A sequence of bytes. The number of bytes is unknown up front, and
while decoding only determined by the number of bytes remaining. The
binary representation of the sequence of bytes is stored encrypted
using a Blowfish cipher, based on a shared secret. The format reserves
256 bytes for the encrypted sequence of bytes.

------



    
